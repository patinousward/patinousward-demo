package com.patinousward.interview;

/**
 * java序列化
 */
public class Interview03 {
    //https://juejin.im/post/5ce3cdc8e51d45777b1a3cdf#heading-3
    /**
     * 1.实现Serializable  接口，使用ObjectInputStream，ObjectInputStream进行读写
     *
     * 反序列的对象是由JVM自己生成的对象，不通过构造方法生成。
     *
     * 如果一个可序列化的类的成员不是基本类型，也不是String类型，那这个引用类型也必须是可序列化的；
     * 否则，会导致此类不能序列化。
     *
     * 同一对象序列化多次的机制
     * 同一对象序列化多次，会将这个对象序列化多次吗？答案是否定的。
     *
     * 反序列化的顺序与序列化时的顺序一致。（如果是写到同一个文件中的话）
     *
     * Java序列化算法
     * 所有保存到磁盘的对象都有一个序列化编码号
     *
     * 当程序试图序列化一个对象时，会先检查此对象是否已经序列化过，只有此对象从未（在此虚拟机）被序列化过，才会将此对象序列化为字节序列输出。
     *
     * 如果此对象已经序列化过，则直接输出编号即可。
     *
     * 潜在问题：
     * 如果序列化一个可变对象（对象内的内容可更改）后，更改了对象内容，再次序列化，并不会再次将此对象转换为字节序列，而只是保存序列化编号。
     *
     *
     * 使用transient关键字选择不需要序列化的字段。（使用transient修饰的属性，java序列化时，会忽略掉此字段，所以反序列化出的对象，被transient修饰的属性是默认值。对于引用类型，值是null；基本类型，值是0；boolean类型，值是false。）
     *
     *
     *
     * 2、Externalizable：强制自定义序列化
     * 通过实现Externalizable接口，必须实现writeExternal、readExternal方法。
     *
     * Externalizable接口不同于Serializable接口，实现此接口必须实现接口中的两个方法实现自定义序列化，这是强制性的；特别之处是必须提供pulic的无参构造器，因为在反序列化的时候需要反射创建对象。
     *
     *
     * private static final long serialVersionUID = 1111013L;
     *
     * 序列化版本号可自由指定，如果不指定，JVM会根据类信息自己计算一个版本号，这样随着class的升级，就无法正确反序列化；不指定版本号另一个明显隐患是，不利于jvm间的移植，可能class文件没有更改，但不同jvm可能计算的规则不一样，这样也会导致无法反序列化。
     * 什么情况下需要修改serialVersionUID呢？分三种情况。
     *
     * 如果只是修改了方法，反序列化不容影响，则无需修改版本号；
     * 如果只是修改了静态变量，瞬态变量（transient修饰的变量），反序列化不受影响，无需修改版本号；
     * 如果修改了非瞬态变量，则可能导致反序列化失败。如果新类中实例变量的类型与序列化时类的类型不一致，则会反序列化失败，这时候需要更改serialVersionUID。
     * 如果只是新增了实例变量，则反序列化回来新增的是默认值；如果减少了实例变量，反序列化时会忽略掉减少的实例变量。
     *
     * 即，老的类中序列化成文件，然后新类新增一个属性，然后去读这个文件中的对象
     *
     * 如果反序列化使用的class的版本号与序列化时使用的不一致，反序列化会报InvalidClassException异常。
     *`
     *
     * 总结:
     * 所有需要网络传输的对象都需要实现序列化接口，通过建议所有的javaBean都实现Serializable接口。
     * 对象的类名、实例变量（包括基本类型，数组，对其他对象的引用）都会被序列化；方法、类变量、transient实例变量都不会被序列化。
     * 如果想让某个变量不被序列化，使用transient修饰。
     * 序列化对象的引用类型成员变量，也必须是可序列化的，否则，会报错。
     * 反序列化时必须有序列化对象的class文件。
     * 当通过文件、网络来读取序列化后的对象时，必须按照实际写入的顺序读取。
     * 单例类序列化，需要重写readResolve()方法；否则会破坏单例原则。
     * 同一对象序列化多次，只有第一次序列化为二进制流，以后都只是保存序列化编号，不会重复序列化。
     * 建议所有可序列化的类加上serialVersionUID 版本号，方便项目升级。


     * writeReplace：在序列化时，会先调用此方法，再调用writeObject方法。此方法可将任意对象代替目标序列化对象
     * readResolve：反序列化时替换反序列化出的对象，反序列化出来的对象被立即丢弃。此方法在readeObject后调用。
     * readResolve常用来反序列单例类，保证单例类的唯一性。
     *
     */
}
